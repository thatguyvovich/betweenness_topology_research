# -*- coding: utf-8 -*-
"""PRS.ipynb

Automatically generated by Colaboratory.

Original file is located atplt

"""

import matplotlib.pyplot as plt
import numpy as np
import math
import sys
from typing import List
# LLVM compiler
from numba import njit

class AbstractPathfinder:
    # Adjacency matrix
    MA: List[List[int]]
    # Distance matrix
    MD: List[List[int]]
    # Next matrix
    MN: List[List[int]]

    # Method that returns a matrix of paths
    def find_paths() -> List[List[int]]: ...

    # Internal function that calculates paths
    def __path_reconstructor(): ...


class FloydWarshallPathfinder(AbstractPathfinder):

    def find_paths(self, MA) -> List[List[int]]:
        self.MA = MA
        self.__path_reconstructor()
        return self.MD, self.MN
    
    def __path_reconstructor(self):
        """
        Reconstructs the shortest path between two nodes in a graph using Floyd's algorithm
        :param MA: Adjacency matrix
        :return: A matrix of the shortest path between two nodes in the graph
        """
        distance = np.zeros(shape=(len(self.MA), len(self.MA)), dtype=np.int64)
        distance = np.copy(self.MA)
        next = np.zeros(shape=(len(self.MA), len(self.MA)), dtype=np.int64)
        for i in range(len(self.MA)):
            for j in range(len(self.MA)):
                if distance[i, j] == 0:
                    distance[i, j] = 9000000
                elif distance[i, j] == 1:
                    next[i, j] = j
                elif i == j:
                    distance[i, i] = 0
                    next[i, i] = i
        
        for k in range(len(self.MA)):
            for i in range(len(self.MA)):
                for j in range(len(self.MA)):
                    if distance[i, j] > distance[i, k] + distance[k, j]:
                        distance[i, j] = distance[i, k] + distance[k, j]
                        next[i][j] = next[i][k]

            
        for i in range(len(self.MA)):
            next[i, i] = i
            for j in range(len(self.MA)):
                next[j, i] = next[i, j]
        
        self.MD = distance
        self.MN = next

@njit
def ToDistanceMatrix(MA):
    """
    MA - adjacency matrix

    return distance matrix
    """
    distance = np.zeros(shape=(len(MA), len(MA)), dtype=np.int64)
    distance = np.copy(MA)
    for i in range(len(MA)):
        for j in range(len(MA)):
            if distance[i, j] == 0:
                distance[i, j] = 9000000

    for k in range(len(MA)):
        for i in range(len(MA)):
            for j in range(len(MA)):
                if distance[i, j] > distance[i, k] + distance[k, j]:
                    distance[i, j] = distance[i, k] + distance[k, j]
    
    for i in range(len(MA)):
        distance[i, i] = 0
        for j in range(len(MA)):
            distance[j, i] = distance[i, j]

    return distance


def FloydPathReconstruct(MA):
    pass

def Betweeness(MA):
    betweeness = [np.count_nonzero(MA == i) for i in range(len(MA))]
    return betweeness

def ToBetweenessVector(MA):
    distance = np.zeros(shape=(len(MA), len(MA)), dtype=np.int64)
    distance = np.copy(MA)
    betweeness = np.zeros(shape=(len(MA)), dtype=np.int64)
    for i in range(len(MA)):
        for j in range(len(MA)):
            if distance[i, j] == 0:
                distance[i, j] = 9000000

    for k in range(len(MA)):
        for i in range(len(MA)):
            for j in range(len(MA)):
                if distance[i, j] > distance[i, k] + distance[k, j]:
                    distance[i, j] = distance[i, k] + distance[k, j]
                    betweeness[k] = betweeness[k] + 1
    
    for i in range(len(MA)):
        distance[i, i] = 0
        for j in range(len(MA)):
            distance[j, i] = distance[i, j]

    return betweeness


def CopyDiagonalMatrix(MF):
    """
    Copy the diagonal of a matrix to the other diagonal
    """
    size = len(MF)
    for i in range(size):
        for j in range(i, size):
            MF[j][i] = MF[i][j]
    return MF


def JavaMatrixToPython(MF: str):
    """
    A function that takes in a string representation of a matrix as in Jave and returns a python matrix
    """
    MF = MF.replace("{", "")
    MF = MF.replace("}", "")
    MF = MF.replace(" ", "")
    MF = MF.split(",")
    MF = [int(i) for i in MF]
    MF = np.array(MF)
    MF = MF.reshape((int(len(MF) ** (1 / 2)), int(len(MF) ** (1 / 2))))
    return MF


def main():
    """
    Entry point for tests during development
    """

    """#Dragon-tree"""

    dragon_tree = '{0, 1, 1, 1, 0, 0, 0, 0, 0}, {0, 0, 1, 0, 1, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 1, 0, 0, 0}, {0, 0, 0, 0, 1, 1, 0, 0, 0}, {0, 0, 0, 0, 0, 1, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 1, 1}, {0, 0, 0, 0, 0, 0, 0, 0, 1}, {0, 0, 0, 0, 0, 0, 1, 1, 0}}'
    dragon_tree = JavaMatrixToPython(dragon_tree)
    dragon_tree = CopyDiagonalMatrix(dragon_tree)

    FWP = FloydWarshallPathfinder()
    MA, MN = FWP.find_paths(dragon_tree)
    print(MN)
    print(Betweeness(MN))

    betweeness_results = Betweeness(MN)

    len(betweeness_results)

    betweeness_results.index(max(betweeness_results))

    combo_dragon_tree_new = np.array(combo_dragon_tree)
    for i in range(math.floor(len(betweeness_results) * 0.3)):
        max_index = betweeness_results.index(max(betweeness_results))
        combo_dragon_tree_new = np.delete(combo_dragon_tree_new, max_index, axis=0)
        combo_dragon_tree_new = np.delete(combo_dragon_tree_new, max_index, axis=1)
        MA, MN = FloydPathReconstruct(combo_dragon_tree_new)
        betweeness_results = Betweeness(MN)
        print(betweeness_results)

    combo_dragon_tree_new = np.array(combo_dragon_tree)
    combo_dragon_tree_new = np.delete(combo_dragon_tree_new, 2, axis=0)
    combo_dragon_tree_new = np.delete(combo_dragon_tree_new, 2, axis=1)

    MA, MN = FloydPathReconstruct(combo_dragon_tree_new)
    print(MN)
    print(Betweeness(MN))

    combo_dragon_tree_new = np.delete(combo_dragon_tree_new, 0, axis=0)
    combo_dragon_tree_new = np.delete(combo_dragon_tree_new, 0, axis=1)

    MA, MN = FloydPathReconstruct(combo_dragon_tree_new)
    print(MN)
    print(Betweeness(MN))

    pass

if __name__ == "__main__":
    main()